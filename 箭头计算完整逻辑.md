# 箭头符号计算的完整逻辑

## 我之前的错误理解

我之前认为箭头计算只需要简单查询规则表：
```
箭头 = 查询规则表(行星, 闸门, 爻线)
```

**这是错误的！** 只有80-90%准确率。

## 正确的完整逻辑

从SharpAstrology代码分析，箭头计算有**两个步骤**：

### 步骤1: 直接规则表查询
```csharp
result.FixingState = _getStateFromStatesTable(planet, activation.Gate, activation.Line);
```

例如：
- Neptune + Gate37 + Line4 → **None** (没有直接规则)

### 步骤2: HarmonicGates聚合（关键！）

```csharp
foreach (var harmonicGate in activation.Gate.HarmonicGates())
{
    // 2.1 在同一端（个性/设计）中聚合
    result.FixingState |= _aggregateStateFromHarmonicGate(
        activation.Gate, activation.Line, harmonicGate, activations);

    // 2.2 从另一端（设计/个性）聚合
    var fixingState = _aggregateStateFromHarmonicGate(
        activation.Gate, activation.Line, harmonicGate, comparerActivations);
    if (!result.FixingState.HasFlag(fixingState)) {
        result.FixingState |= fixingState;
        result.FixingStateChangedByComparer = true;  // 标记：箭头是通过跨端聚合得到的
    }
}
```

### HarmonicGates是什么？

**HarmonicGates = 构成通道的两个闸门**

例如：
- Gate 37的HarmonicGate = Gate 40 (37-40构成通道)
- Gate 48的HarmonicGate = Gate 16 (48-16构成通道)
- Gate 32的HarmonicGate = Gate 54 (32-54构成通道)

### 聚合逻辑详解（_aggregateStateFromHarmonicGate）

```csharp
private static FixingState _aggregateStateFromHarmonicGate(
    Gates gate, Lines line, Gates harmonicGate,
    Dictionary<Planets, Activation> activations)
{
    var state = FixingState.None;

    // 找到所有激活harmonicGate的行星
    var states = activations
        .Where(x => x.Value.Gate == harmonicGate)

        // 对每个激活harmonicGate的行星X，查询：
        // 规则表(行星X, 当前gate, 当前line)
        .Select(x => _getStateFromStatesTable(x.Key, gate, line))
        .ToArray();

    // 用位或（|）合并所有状态
    if (states.Length != 0)
    {
        state |= states.Aggregate((a, b) => a | b);
    }

    return state;
}
```

## 三种特殊情况解析

### 第1种 - 同闸门不同爻线聚合

**情况**：
- 规则表定义：PlanetA + GateX + LineY → ▲
- 实际图中：PlanetB在GateX.LineZ（本来查PlanetB + GateX + LineZ = None）
- **但是**：PlanetA也在GateX.LineY（另一个爻线）
- **结果**：PlanetB的GateX.LineZ可以获得箭头

**代码对应**：
```csharp
// 在同一端聚合时，harmonicGate就是当前gate本身
result.FixingState |= _aggregateStateFromHarmonicGate(
    activation.Gate, activation.Line, activation.Gate, activations);
```

**注意**：SharpAstrology代码中，HarmonicGates应该包括当前gate本身才能实现这个逻辑。需要检查`Gate.HarmonicGates()`的实现。

### 第2种 - 跨端同闸门链接

**情况**：
- 个性端某行星在GateX
- 设计端某行星也在GateX
- 这种跨端的同闸门激活需要特殊标注

**代码对应**：
与第1种类似，但是通过comparerActivations（另一端）来查询。

### 第3种 - 通道链接（最重要！★★★）

**情况**：
- 规则表定义：PlanetA + GateX + LineY → ▲
- 实际图中：PlanetB在GateZ.LineY（本来查PlanetB + GateZ + LineY = None）
- **但是**：PlanetA在GateX，而GateX和GateZ构成通道（harmonicGates）
- **结果**：PlanetB的GateZ.LineY可以获得箭头（通过PlanetA+GateZ+LineY的规则）

**代码对应**：
```csharp
foreach (var harmonicGate in activation.Gate.HarmonicGates())
{
    // harmonicGate = 与当前gate构成通道的另一个gate

    // 查找所有激活harmonicGate的行星
    var planetsAtHarmonic = activations.Where(x => x.Value.Gate == harmonicGate);

    // 对每个激活harmonicGate的行星，查询它对当前gate+line的规则
    foreach (var planet in planetsAtHarmonic)
    {
        var state = _getStateFromStatesTable(planet.Key, activation.Gate, activation.Line);
        result.FixingState |= state;
    }
}
```

## 海王星37.4的完整解析

### 2017-01-20案例

**设计端数据**：
- Neptune: 37.4
- Moon: 40.1

**步骤1：直接查询**
```
Neptune + Gate37 + Line4 → None (没有规则)
```

**步骤2：HarmonicGates聚合**

1. Gate37的HarmonicGate = Gate40（37-40构成通道）

2. 查找谁激活了Gate40？→ Moon在40.1

3. 查询规则表：**Moon + Gate37 + Line4 → ?**

4. 从《区分的科学》原文Line 117找到：
   ```
   月亮 37.4 → ▲ Exalted
   ```

5. 聚合：
   ```
   Neptune 37.4的箭头 = None | Exalted = Exalted (▲)
   ```

**所以Neptune 37.4显示▲！**

## 1983-10-15 水星48.1的完整解析

**个性端数据**：
- Sun: 32.1
- Mercury: 48.1

**步骤1：直接查询**
```
Mercury + Gate48 + Line1 → None (规则表Line 729只有48.3是Detriment)
```

**步骤2：HarmonicGates聚合**

1. Gate48的HarmonicGate = Gate16（48-16构成通道）

2. 查找谁激活了Gate16？→ **没有行星在Gate16**

3. 所以聚合结果 = None

**但是！让我检查是否有其他行星在Gate48的其他爻线...**

从SharpAstrology规则表Line 134-137:
```csharp
Planets.Moon => (gate, line) switch
{
    (Gates.Key48, Lines.One) => FixingState.Exalted,   // ← 月亮48.1是▲！
    (Gates.Key48, Lines.Three) => FixingState.Exalted,
    (Gates.Key48, Lines.Five) => FixingState.Detriment,
    (Gates.Key48, Lines.Six) => FixingState.Detriment,
}
```

**需要检查：1983-10-15案例中，月亮在哪里？**
- 从截图3：红月亮（设计月亮）48.4，黑月亮（个性月亮）41.5

**所以：**
- 个性端：Mercury在48.1，Moon在41.5（不在Gate48）
- 设计端：Moon在48.4

**如果考虑跨端聚合（comparerActivations）：**
1. Mercury 48.1查询HarmonicGates
2. Gate48的harmonicGate = Gate16
3. **还需要查：设计端的Moon在48.4，它能为Mercury 48.1提供箭头吗？**

**注意**：聚合逻辑不是"同一个闸门的其他爻线"，而是：
- 找到激活harmonicGate的行星X
- 查询：X + 当前gate + 当前line

所以：
- Mercury在48.1
- 需要找：谁激活了Gate16？
- 如果没人激活Gate16，就无法通过聚合获得箭头

**我之前的错误**：我错误地认为北交点45.1有箭头，因为我用Jupiter的规则去查了。但北交点应该有自己的规则表。

## 星号标注（Juxtaposed ✲）

从规则表和代码分析：

```csharp
public enum FixingState
{
    None = 0,
    Exalted = 1,      // ▲
    Detriment = 2,    // ▼
    Juxtaposed = 3    // ✲ = Exalted | Detriment (同时有两种状态)
}
```

**星号出现的情况**：
- 直接规则返回Juxtaposed
- 或聚合后：Exalted | Detriment = Juxtaposed

**例子**：
从《区分的科学》原文Line 5404-5405:
```
闸门49第4爻—启蒙 / 无明
▲  ▽在此极神秘的相位，既无上升也无下降，因为事实上，两者并无不同。
```

这种爻线标注✲星号。

## 实现难度评估

### 简单方法（80-90%准确）
只查直接规则表：
- ✅ 实现简单
- ✅ 大部分情况正确
- ❌ 遗漏需要聚合的情况（如Neptune 37.4）

### 完整方法（100%准确）
实现完整的聚合逻辑：
- ❌ 需要HarmonicGates映射表
- ❌ 需要实现`_aggregateStateFromHarmonicGate`逻辑
- ❌ 需要同时考虑个性端和设计端的相互影响
- ❌ **复杂度较高**

## 建议

1. **先实现简单方法**（直接查规则表），80-90%的箭头会正确
2. **后期再实现聚合逻辑**，达到100%准确
3. **需要提取HarmonicGates映射表**（哪些闸门构成通道）
4. **需要处理北交点/南交点的规则**（它们可能没有自己的规则表，或使用特殊逻辑）

---

**结论：** 箭头符号的计算确实比想象的复杂得多！需要实现两层逻辑：直接查询 + HarmonicGates聚合。
